package service

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/cyxrop/homework-2/internal/app/service/user.MailPoller -o ./internal/app/service/user/mail_poller_mock_test.go -n MailPollerMock

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/cyxrop/homework-2/internal/app/mail"
)

// MailPollerMock implements MailPoller
type MailPollerMock struct {
	t minimock.Tester

	funcPoll          func(s1 string, s2 string, t1 time.Time, i1 int64) (p1 mail.PollResult, err error)
	inspectFuncPoll   func(s1 string, s2 string, t1 time.Time, i1 int64)
	afterPollCounter  uint64
	beforePollCounter uint64
	PollMock          mMailPollerMockPoll
}

// NewMailPollerMock returns a mock for MailPoller
func NewMailPollerMock(t minimock.Tester) *MailPollerMock {
	m := &MailPollerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.PollMock = mMailPollerMockPoll{mock: m}
	m.PollMock.callArgs = []*MailPollerMockPollParams{}

	return m
}

type mMailPollerMockPoll struct {
	mock               *MailPollerMock
	defaultExpectation *MailPollerMockPollExpectation
	expectations       []*MailPollerMockPollExpectation

	callArgs []*MailPollerMockPollParams
	mutex    sync.RWMutex
}

// MailPollerMockPollExpectation specifies expectation struct of the MailPoller.Poll
type MailPollerMockPollExpectation struct {
	mock    *MailPollerMock
	params  *MailPollerMockPollParams
	results *MailPollerMockPollResults
	Counter uint64
}

// MailPollerMockPollParams contains parameters of the MailPoller.Poll
type MailPollerMockPollParams struct {
	s1 string
	s2 string
	t1 time.Time
	i1 int64
}

// MailPollerMockPollResults contains results of the MailPoller.Poll
type MailPollerMockPollResults struct {
	p1  mail.PollResult
	err error
}

// Expect sets up expected params for MailPoller.Poll
func (mmPoll *mMailPollerMockPoll) Expect(s1 string, s2 string, t1 time.Time, i1 int64) *mMailPollerMockPoll {
	if mmPoll.mock.funcPoll != nil {
		mmPoll.mock.t.Fatalf("MailPollerMock.Poll mock is already set by Set")
	}

	if mmPoll.defaultExpectation == nil {
		mmPoll.defaultExpectation = &MailPollerMockPollExpectation{}
	}

	mmPoll.defaultExpectation.params = &MailPollerMockPollParams{s1, s2, t1, i1}
	for _, e := range mmPoll.expectations {
		if minimock.Equal(e.params, mmPoll.defaultExpectation.params) {
			mmPoll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPoll.defaultExpectation.params)
		}
	}

	return mmPoll
}

// Inspect accepts an inspector function that has same arguments as the MailPoller.Poll
func (mmPoll *mMailPollerMockPoll) Inspect(f func(s1 string, s2 string, t1 time.Time, i1 int64)) *mMailPollerMockPoll {
	if mmPoll.mock.inspectFuncPoll != nil {
		mmPoll.mock.t.Fatalf("Inspect function is already set for MailPollerMock.Poll")
	}

	mmPoll.mock.inspectFuncPoll = f

	return mmPoll
}

// Return sets up results that will be returned by MailPoller.Poll
func (mmPoll *mMailPollerMockPoll) Return(p1 mail.PollResult, err error) *MailPollerMock {
	if mmPoll.mock.funcPoll != nil {
		mmPoll.mock.t.Fatalf("MailPollerMock.Poll mock is already set by Set")
	}

	if mmPoll.defaultExpectation == nil {
		mmPoll.defaultExpectation = &MailPollerMockPollExpectation{mock: mmPoll.mock}
	}
	mmPoll.defaultExpectation.results = &MailPollerMockPollResults{p1, err}
	return mmPoll.mock
}

//Set uses given function f to mock the MailPoller.Poll method
func (mmPoll *mMailPollerMockPoll) Set(f func(s1 string, s2 string, t1 time.Time, i1 int64) (p1 mail.PollResult, err error)) *MailPollerMock {
	if mmPoll.defaultExpectation != nil {
		mmPoll.mock.t.Fatalf("Default expectation is already set for the MailPoller.Poll method")
	}

	if len(mmPoll.expectations) > 0 {
		mmPoll.mock.t.Fatalf("Some expectations are already set for the MailPoller.Poll method")
	}

	mmPoll.mock.funcPoll = f
	return mmPoll.mock
}

// When sets expectation for the MailPoller.Poll which will trigger the result defined by the following
// Then helper
func (mmPoll *mMailPollerMockPoll) When(s1 string, s2 string, t1 time.Time, i1 int64) *MailPollerMockPollExpectation {
	if mmPoll.mock.funcPoll != nil {
		mmPoll.mock.t.Fatalf("MailPollerMock.Poll mock is already set by Set")
	}

	expectation := &MailPollerMockPollExpectation{
		mock:   mmPoll.mock,
		params: &MailPollerMockPollParams{s1, s2, t1, i1},
	}
	mmPoll.expectations = append(mmPoll.expectations, expectation)
	return expectation
}

// Then sets up MailPoller.Poll return parameters for the expectation previously defined by the When method
func (e *MailPollerMockPollExpectation) Then(p1 mail.PollResult, err error) *MailPollerMock {
	e.results = &MailPollerMockPollResults{p1, err}
	return e.mock
}

// Poll implements MailPoller
func (mmPoll *MailPollerMock) Poll(s1 string, s2 string, t1 time.Time, i1 int64) (p1 mail.PollResult, err error) {
	mm_atomic.AddUint64(&mmPoll.beforePollCounter, 1)
	defer mm_atomic.AddUint64(&mmPoll.afterPollCounter, 1)

	if mmPoll.inspectFuncPoll != nil {
		mmPoll.inspectFuncPoll(s1, s2, t1, i1)
	}

	mm_params := &MailPollerMockPollParams{s1, s2, t1, i1}

	// Record call args
	mmPoll.PollMock.mutex.Lock()
	mmPoll.PollMock.callArgs = append(mmPoll.PollMock.callArgs, mm_params)
	mmPoll.PollMock.mutex.Unlock()

	for _, e := range mmPoll.PollMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmPoll.PollMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPoll.PollMock.defaultExpectation.Counter, 1)
		mm_want := mmPoll.PollMock.defaultExpectation.params
		mm_got := MailPollerMockPollParams{s1, s2, t1, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPoll.t.Errorf("MailPollerMock.Poll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPoll.PollMock.defaultExpectation.results
		if mm_results == nil {
			mmPoll.t.Fatal("No results are set for the MailPollerMock.Poll")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmPoll.funcPoll != nil {
		return mmPoll.funcPoll(s1, s2, t1, i1)
	}
	mmPoll.t.Fatalf("Unexpected call to MailPollerMock.Poll. %v %v %v %v", s1, s2, t1, i1)
	return
}

// PollAfterCounter returns a count of finished MailPollerMock.Poll invocations
func (mmPoll *MailPollerMock) PollAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPoll.afterPollCounter)
}

// PollBeforeCounter returns a count of MailPollerMock.Poll invocations
func (mmPoll *MailPollerMock) PollBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPoll.beforePollCounter)
}

// Calls returns a list of arguments used in each call to MailPollerMock.Poll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPoll *mMailPollerMockPoll) Calls() []*MailPollerMockPollParams {
	mmPoll.mutex.RLock()

	argCopy := make([]*MailPollerMockPollParams, len(mmPoll.callArgs))
	copy(argCopy, mmPoll.callArgs)

	mmPoll.mutex.RUnlock()

	return argCopy
}

// MinimockPollDone returns true if the count of the Poll invocations corresponds
// the number of defined expectations
func (m *MailPollerMock) MinimockPollDone() bool {
	for _, e := range m.PollMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PollMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPollCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPoll != nil && mm_atomic.LoadUint64(&m.afterPollCounter) < 1 {
		return false
	}
	return true
}

// MinimockPollInspect logs each unmet expectation
func (m *MailPollerMock) MinimockPollInspect() {
	for _, e := range m.PollMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MailPollerMock.Poll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PollMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPollCounter) < 1 {
		if m.PollMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MailPollerMock.Poll")
		} else {
			m.t.Errorf("Expected call to MailPollerMock.Poll with params: %#v", *m.PollMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPoll != nil && mm_atomic.LoadUint64(&m.afterPollCounter) < 1 {
		m.t.Error("Expected call to MailPollerMock.Poll")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MailPollerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockPollInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MailPollerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MailPollerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockPollDone()
}
