package service

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/cyxrop/homework-2/internal/app/service/user.UserRepository -o ./internal/app/service/user/user_repository_mock_test.go -n UserRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/cyxrop/homework-2/internal/app/models"
)

// UserRepositoryMock implements UserRepository
type UserRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, u1 models.User) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, u1 models.User)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUserRepositoryMockCreate

	funcCreateMailbox          func(ctx context.Context, s1 string, m1 models.Mailbox) (i1 int64, err error)
	inspectFuncCreateMailbox   func(ctx context.Context, s1 string, m1 models.Mailbox)
	afterCreateMailboxCounter  uint64
	beforeCreateMailboxCounter uint64
	CreateMailboxMock          mUserRepositoryMockCreateMailbox

	funcDeleteByTgUsername          func(ctx context.Context, s1 string) (err error)
	inspectFuncDeleteByTgUsername   func(ctx context.Context, s1 string)
	afterDeleteByTgUsernameCounter  uint64
	beforeDeleteByTgUsernameCounter uint64
	DeleteByTgUsernameMock          mUserRepositoryMockDeleteByTgUsername

	funcDeleteMailbox          func(ctx context.Context, s1 string, s2 string) (err error)
	inspectFuncDeleteMailbox   func(ctx context.Context, s1 string, s2 string)
	afterDeleteMailboxCounter  uint64
	beforeDeleteMailboxCounter uint64
	DeleteMailboxMock          mUserRepositoryMockDeleteMailbox

	funcGetByTgUsername          func(ctx context.Context, s1 string) (u1 models.User, err error)
	inspectFuncGetByTgUsername   func(ctx context.Context, s1 string)
	afterGetByTgUsernameCounter  uint64
	beforeGetByTgUsernameCounter uint64
	GetByTgUsernameMock          mUserRepositoryMockGetByTgUsername

	funcGetList          func(ctx context.Context) (ua1 []models.User, err error)
	inspectFuncGetList   func(ctx context.Context)
	afterGetListCounter  uint64
	beforeGetListCounter uint64
	GetListMock          mUserRepositoryMockGetList

	funcGetMailboxes          func(ctx context.Context, s1 string) (ma1 []models.Mailbox, err error)
	inspectFuncGetMailboxes   func(ctx context.Context, s1 string)
	afterGetMailboxesCounter  uint64
	beforeGetMailboxesCounter uint64
	GetMailboxesMock          mUserRepositoryMockGetMailboxes
}

// NewUserRepositoryMock returns a mock for UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock {
	m := &UserRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mUserRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*UserRepositoryMockCreateParams{}

	m.CreateMailboxMock = mUserRepositoryMockCreateMailbox{mock: m}
	m.CreateMailboxMock.callArgs = []*UserRepositoryMockCreateMailboxParams{}

	m.DeleteByTgUsernameMock = mUserRepositoryMockDeleteByTgUsername{mock: m}
	m.DeleteByTgUsernameMock.callArgs = []*UserRepositoryMockDeleteByTgUsernameParams{}

	m.DeleteMailboxMock = mUserRepositoryMockDeleteMailbox{mock: m}
	m.DeleteMailboxMock.callArgs = []*UserRepositoryMockDeleteMailboxParams{}

	m.GetByTgUsernameMock = mUserRepositoryMockGetByTgUsername{mock: m}
	m.GetByTgUsernameMock.callArgs = []*UserRepositoryMockGetByTgUsernameParams{}

	m.GetListMock = mUserRepositoryMockGetList{mock: m}
	m.GetListMock.callArgs = []*UserRepositoryMockGetListParams{}

	m.GetMailboxesMock = mUserRepositoryMockGetMailboxes{mock: m}
	m.GetMailboxesMock.callArgs = []*UserRepositoryMockGetMailboxesParams{}

	return m
}

type mUserRepositoryMockCreate struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockCreateExpectation
	expectations       []*UserRepositoryMockCreateExpectation

	callArgs []*UserRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// UserRepositoryMockCreateExpectation specifies expectation struct of the UserRepository.Create
type UserRepositoryMockCreateExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockCreateParams
	results *UserRepositoryMockCreateResults
	Counter uint64
}

// UserRepositoryMockCreateParams contains parameters of the UserRepository.Create
type UserRepositoryMockCreateParams struct {
	ctx context.Context
	u1  models.User
}

// UserRepositoryMockCreateResults contains results of the UserRepository.Create
type UserRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Expect(ctx context.Context, u1 models.User) *mUserRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &UserRepositoryMockCreateParams{ctx, u1}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Inspect(f func(ctx context.Context, u1 models.User)) *mUserRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Return(i1 int64, err error) *UserRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UserRepositoryMockCreateResults{i1, err}
	return mmCreate.mock
}

//Set uses given function f to mock the UserRepository.Create method
func (mmCreate *mUserRepositoryMockCreate) Set(f func(ctx context.Context, u1 models.User) (i1 int64, err error)) *UserRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the UserRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUserRepositoryMockCreate) When(ctx context.Context, u1 models.User) *UserRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
	}

	expectation := &UserRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &UserRepositoryMockCreateParams{ctx, u1},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.Create return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateExpectation) Then(i1 int64, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Create implements UserRepository
func (mmCreate *UserRepositoryMock) Create(ctx context.Context, u1 models.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, u1)
	}

	mm_params := &UserRepositoryMockCreateParams{ctx, u1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := UserRepositoryMockCreateParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UserRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, u1)
	}
	mmCreate.t.Fatalf("Unexpected call to UserRepositoryMock.Create. %v %v", ctx, u1)
	return
}

// CreateAfterCounter returns a count of finished UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUserRepositoryMockCreate) Calls() []*UserRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UserRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.Create")
	}
}

type mUserRepositoryMockCreateMailbox struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockCreateMailboxExpectation
	expectations       []*UserRepositoryMockCreateMailboxExpectation

	callArgs []*UserRepositoryMockCreateMailboxParams
	mutex    sync.RWMutex
}

// UserRepositoryMockCreateMailboxExpectation specifies expectation struct of the UserRepository.CreateMailbox
type UserRepositoryMockCreateMailboxExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockCreateMailboxParams
	results *UserRepositoryMockCreateMailboxResults
	Counter uint64
}

// UserRepositoryMockCreateMailboxParams contains parameters of the UserRepository.CreateMailbox
type UserRepositoryMockCreateMailboxParams struct {
	ctx context.Context
	s1  string
	m1  models.Mailbox
}

// UserRepositoryMockCreateMailboxResults contains results of the UserRepository.CreateMailbox
type UserRepositoryMockCreateMailboxResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for UserRepository.CreateMailbox
func (mmCreateMailbox *mUserRepositoryMockCreateMailbox) Expect(ctx context.Context, s1 string, m1 models.Mailbox) *mUserRepositoryMockCreateMailbox {
	if mmCreateMailbox.mock.funcCreateMailbox != nil {
		mmCreateMailbox.mock.t.Fatalf("UserRepositoryMock.CreateMailbox mock is already set by Set")
	}

	if mmCreateMailbox.defaultExpectation == nil {
		mmCreateMailbox.defaultExpectation = &UserRepositoryMockCreateMailboxExpectation{}
	}

	mmCreateMailbox.defaultExpectation.params = &UserRepositoryMockCreateMailboxParams{ctx, s1, m1}
	for _, e := range mmCreateMailbox.expectations {
		if minimock.Equal(e.params, mmCreateMailbox.defaultExpectation.params) {
			mmCreateMailbox.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateMailbox.defaultExpectation.params)
		}
	}

	return mmCreateMailbox
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.CreateMailbox
func (mmCreateMailbox *mUserRepositoryMockCreateMailbox) Inspect(f func(ctx context.Context, s1 string, m1 models.Mailbox)) *mUserRepositoryMockCreateMailbox {
	if mmCreateMailbox.mock.inspectFuncCreateMailbox != nil {
		mmCreateMailbox.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.CreateMailbox")
	}

	mmCreateMailbox.mock.inspectFuncCreateMailbox = f

	return mmCreateMailbox
}

// Return sets up results that will be returned by UserRepository.CreateMailbox
func (mmCreateMailbox *mUserRepositoryMockCreateMailbox) Return(i1 int64, err error) *UserRepositoryMock {
	if mmCreateMailbox.mock.funcCreateMailbox != nil {
		mmCreateMailbox.mock.t.Fatalf("UserRepositoryMock.CreateMailbox mock is already set by Set")
	}

	if mmCreateMailbox.defaultExpectation == nil {
		mmCreateMailbox.defaultExpectation = &UserRepositoryMockCreateMailboxExpectation{mock: mmCreateMailbox.mock}
	}
	mmCreateMailbox.defaultExpectation.results = &UserRepositoryMockCreateMailboxResults{i1, err}
	return mmCreateMailbox.mock
}

//Set uses given function f to mock the UserRepository.CreateMailbox method
func (mmCreateMailbox *mUserRepositoryMockCreateMailbox) Set(f func(ctx context.Context, s1 string, m1 models.Mailbox) (i1 int64, err error)) *UserRepositoryMock {
	if mmCreateMailbox.defaultExpectation != nil {
		mmCreateMailbox.mock.t.Fatalf("Default expectation is already set for the UserRepository.CreateMailbox method")
	}

	if len(mmCreateMailbox.expectations) > 0 {
		mmCreateMailbox.mock.t.Fatalf("Some expectations are already set for the UserRepository.CreateMailbox method")
	}

	mmCreateMailbox.mock.funcCreateMailbox = f
	return mmCreateMailbox.mock
}

// When sets expectation for the UserRepository.CreateMailbox which will trigger the result defined by the following
// Then helper
func (mmCreateMailbox *mUserRepositoryMockCreateMailbox) When(ctx context.Context, s1 string, m1 models.Mailbox) *UserRepositoryMockCreateMailboxExpectation {
	if mmCreateMailbox.mock.funcCreateMailbox != nil {
		mmCreateMailbox.mock.t.Fatalf("UserRepositoryMock.CreateMailbox mock is already set by Set")
	}

	expectation := &UserRepositoryMockCreateMailboxExpectation{
		mock:   mmCreateMailbox.mock,
		params: &UserRepositoryMockCreateMailboxParams{ctx, s1, m1},
	}
	mmCreateMailbox.expectations = append(mmCreateMailbox.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.CreateMailbox return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateMailboxExpectation) Then(i1 int64, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockCreateMailboxResults{i1, err}
	return e.mock
}

// CreateMailbox implements UserRepository
func (mmCreateMailbox *UserRepositoryMock) CreateMailbox(ctx context.Context, s1 string, m1 models.Mailbox) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateMailbox.beforeCreateMailboxCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateMailbox.afterCreateMailboxCounter, 1)

	if mmCreateMailbox.inspectFuncCreateMailbox != nil {
		mmCreateMailbox.inspectFuncCreateMailbox(ctx, s1, m1)
	}

	mm_params := &UserRepositoryMockCreateMailboxParams{ctx, s1, m1}

	// Record call args
	mmCreateMailbox.CreateMailboxMock.mutex.Lock()
	mmCreateMailbox.CreateMailboxMock.callArgs = append(mmCreateMailbox.CreateMailboxMock.callArgs, mm_params)
	mmCreateMailbox.CreateMailboxMock.mutex.Unlock()

	for _, e := range mmCreateMailbox.CreateMailboxMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateMailbox.CreateMailboxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateMailbox.CreateMailboxMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateMailbox.CreateMailboxMock.defaultExpectation.params
		mm_got := UserRepositoryMockCreateMailboxParams{ctx, s1, m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateMailbox.t.Errorf("UserRepositoryMock.CreateMailbox got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateMailbox.CreateMailboxMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateMailbox.t.Fatal("No results are set for the UserRepositoryMock.CreateMailbox")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateMailbox.funcCreateMailbox != nil {
		return mmCreateMailbox.funcCreateMailbox(ctx, s1, m1)
	}
	mmCreateMailbox.t.Fatalf("Unexpected call to UserRepositoryMock.CreateMailbox. %v %v %v", ctx, s1, m1)
	return
}

// CreateMailboxAfterCounter returns a count of finished UserRepositoryMock.CreateMailbox invocations
func (mmCreateMailbox *UserRepositoryMock) CreateMailboxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMailbox.afterCreateMailboxCounter)
}

// CreateMailboxBeforeCounter returns a count of UserRepositoryMock.CreateMailbox invocations
func (mmCreateMailbox *UserRepositoryMock) CreateMailboxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMailbox.beforeCreateMailboxCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.CreateMailbox.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateMailbox *mUserRepositoryMockCreateMailbox) Calls() []*UserRepositoryMockCreateMailboxParams {
	mmCreateMailbox.mutex.RLock()

	argCopy := make([]*UserRepositoryMockCreateMailboxParams, len(mmCreateMailbox.callArgs))
	copy(argCopy, mmCreateMailbox.callArgs)

	mmCreateMailbox.mutex.RUnlock()

	return argCopy
}

// MinimockCreateMailboxDone returns true if the count of the CreateMailbox invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateMailboxDone() bool {
	for _, e := range m.CreateMailboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMailboxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateMailboxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMailbox != nil && mm_atomic.LoadUint64(&m.afterCreateMailboxCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateMailboxInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateMailboxInspect() {
	for _, e := range m.CreateMailboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateMailbox with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMailboxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateMailboxCounter) < 1 {
		if m.CreateMailboxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.CreateMailbox")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.CreateMailbox with params: %#v", *m.CreateMailboxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMailbox != nil && mm_atomic.LoadUint64(&m.afterCreateMailboxCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.CreateMailbox")
	}
}

type mUserRepositoryMockDeleteByTgUsername struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockDeleteByTgUsernameExpectation
	expectations       []*UserRepositoryMockDeleteByTgUsernameExpectation

	callArgs []*UserRepositoryMockDeleteByTgUsernameParams
	mutex    sync.RWMutex
}

// UserRepositoryMockDeleteByTgUsernameExpectation specifies expectation struct of the UserRepository.DeleteByTgUsername
type UserRepositoryMockDeleteByTgUsernameExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockDeleteByTgUsernameParams
	results *UserRepositoryMockDeleteByTgUsernameResults
	Counter uint64
}

// UserRepositoryMockDeleteByTgUsernameParams contains parameters of the UserRepository.DeleteByTgUsername
type UserRepositoryMockDeleteByTgUsernameParams struct {
	ctx context.Context
	s1  string
}

// UserRepositoryMockDeleteByTgUsernameResults contains results of the UserRepository.DeleteByTgUsername
type UserRepositoryMockDeleteByTgUsernameResults struct {
	err error
}

// Expect sets up expected params for UserRepository.DeleteByTgUsername
func (mmDeleteByTgUsername *mUserRepositoryMockDeleteByTgUsername) Expect(ctx context.Context, s1 string) *mUserRepositoryMockDeleteByTgUsername {
	if mmDeleteByTgUsername.mock.funcDeleteByTgUsername != nil {
		mmDeleteByTgUsername.mock.t.Fatalf("UserRepositoryMock.DeleteByTgUsername mock is already set by Set")
	}

	if mmDeleteByTgUsername.defaultExpectation == nil {
		mmDeleteByTgUsername.defaultExpectation = &UserRepositoryMockDeleteByTgUsernameExpectation{}
	}

	mmDeleteByTgUsername.defaultExpectation.params = &UserRepositoryMockDeleteByTgUsernameParams{ctx, s1}
	for _, e := range mmDeleteByTgUsername.expectations {
		if minimock.Equal(e.params, mmDeleteByTgUsername.defaultExpectation.params) {
			mmDeleteByTgUsername.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteByTgUsername.defaultExpectation.params)
		}
	}

	return mmDeleteByTgUsername
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.DeleteByTgUsername
func (mmDeleteByTgUsername *mUserRepositoryMockDeleteByTgUsername) Inspect(f func(ctx context.Context, s1 string)) *mUserRepositoryMockDeleteByTgUsername {
	if mmDeleteByTgUsername.mock.inspectFuncDeleteByTgUsername != nil {
		mmDeleteByTgUsername.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.DeleteByTgUsername")
	}

	mmDeleteByTgUsername.mock.inspectFuncDeleteByTgUsername = f

	return mmDeleteByTgUsername
}

// Return sets up results that will be returned by UserRepository.DeleteByTgUsername
func (mmDeleteByTgUsername *mUserRepositoryMockDeleteByTgUsername) Return(err error) *UserRepositoryMock {
	if mmDeleteByTgUsername.mock.funcDeleteByTgUsername != nil {
		mmDeleteByTgUsername.mock.t.Fatalf("UserRepositoryMock.DeleteByTgUsername mock is already set by Set")
	}

	if mmDeleteByTgUsername.defaultExpectation == nil {
		mmDeleteByTgUsername.defaultExpectation = &UserRepositoryMockDeleteByTgUsernameExpectation{mock: mmDeleteByTgUsername.mock}
	}
	mmDeleteByTgUsername.defaultExpectation.results = &UserRepositoryMockDeleteByTgUsernameResults{err}
	return mmDeleteByTgUsername.mock
}

//Set uses given function f to mock the UserRepository.DeleteByTgUsername method
func (mmDeleteByTgUsername *mUserRepositoryMockDeleteByTgUsername) Set(f func(ctx context.Context, s1 string) (err error)) *UserRepositoryMock {
	if mmDeleteByTgUsername.defaultExpectation != nil {
		mmDeleteByTgUsername.mock.t.Fatalf("Default expectation is already set for the UserRepository.DeleteByTgUsername method")
	}

	if len(mmDeleteByTgUsername.expectations) > 0 {
		mmDeleteByTgUsername.mock.t.Fatalf("Some expectations are already set for the UserRepository.DeleteByTgUsername method")
	}

	mmDeleteByTgUsername.mock.funcDeleteByTgUsername = f
	return mmDeleteByTgUsername.mock
}

// When sets expectation for the UserRepository.DeleteByTgUsername which will trigger the result defined by the following
// Then helper
func (mmDeleteByTgUsername *mUserRepositoryMockDeleteByTgUsername) When(ctx context.Context, s1 string) *UserRepositoryMockDeleteByTgUsernameExpectation {
	if mmDeleteByTgUsername.mock.funcDeleteByTgUsername != nil {
		mmDeleteByTgUsername.mock.t.Fatalf("UserRepositoryMock.DeleteByTgUsername mock is already set by Set")
	}

	expectation := &UserRepositoryMockDeleteByTgUsernameExpectation{
		mock:   mmDeleteByTgUsername.mock,
		params: &UserRepositoryMockDeleteByTgUsernameParams{ctx, s1},
	}
	mmDeleteByTgUsername.expectations = append(mmDeleteByTgUsername.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.DeleteByTgUsername return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockDeleteByTgUsernameExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockDeleteByTgUsernameResults{err}
	return e.mock
}

// DeleteByTgUsername implements UserRepository
func (mmDeleteByTgUsername *UserRepositoryMock) DeleteByTgUsername(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteByTgUsername.beforeDeleteByTgUsernameCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteByTgUsername.afterDeleteByTgUsernameCounter, 1)

	if mmDeleteByTgUsername.inspectFuncDeleteByTgUsername != nil {
		mmDeleteByTgUsername.inspectFuncDeleteByTgUsername(ctx, s1)
	}

	mm_params := &UserRepositoryMockDeleteByTgUsernameParams{ctx, s1}

	// Record call args
	mmDeleteByTgUsername.DeleteByTgUsernameMock.mutex.Lock()
	mmDeleteByTgUsername.DeleteByTgUsernameMock.callArgs = append(mmDeleteByTgUsername.DeleteByTgUsernameMock.callArgs, mm_params)
	mmDeleteByTgUsername.DeleteByTgUsernameMock.mutex.Unlock()

	for _, e := range mmDeleteByTgUsername.DeleteByTgUsernameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteByTgUsername.DeleteByTgUsernameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteByTgUsername.DeleteByTgUsernameMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteByTgUsername.DeleteByTgUsernameMock.defaultExpectation.params
		mm_got := UserRepositoryMockDeleteByTgUsernameParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteByTgUsername.t.Errorf("UserRepositoryMock.DeleteByTgUsername got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteByTgUsername.DeleteByTgUsernameMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteByTgUsername.t.Fatal("No results are set for the UserRepositoryMock.DeleteByTgUsername")
		}
		return (*mm_results).err
	}
	if mmDeleteByTgUsername.funcDeleteByTgUsername != nil {
		return mmDeleteByTgUsername.funcDeleteByTgUsername(ctx, s1)
	}
	mmDeleteByTgUsername.t.Fatalf("Unexpected call to UserRepositoryMock.DeleteByTgUsername. %v %v", ctx, s1)
	return
}

// DeleteByTgUsernameAfterCounter returns a count of finished UserRepositoryMock.DeleteByTgUsername invocations
func (mmDeleteByTgUsername *UserRepositoryMock) DeleteByTgUsernameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteByTgUsername.afterDeleteByTgUsernameCounter)
}

// DeleteByTgUsernameBeforeCounter returns a count of UserRepositoryMock.DeleteByTgUsername invocations
func (mmDeleteByTgUsername *UserRepositoryMock) DeleteByTgUsernameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteByTgUsername.beforeDeleteByTgUsernameCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.DeleteByTgUsername.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteByTgUsername *mUserRepositoryMockDeleteByTgUsername) Calls() []*UserRepositoryMockDeleteByTgUsernameParams {
	mmDeleteByTgUsername.mutex.RLock()

	argCopy := make([]*UserRepositoryMockDeleteByTgUsernameParams, len(mmDeleteByTgUsername.callArgs))
	copy(argCopy, mmDeleteByTgUsername.callArgs)

	mmDeleteByTgUsername.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteByTgUsernameDone returns true if the count of the DeleteByTgUsername invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockDeleteByTgUsernameDone() bool {
	for _, e := range m.DeleteByTgUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteByTgUsernameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteByTgUsernameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteByTgUsername != nil && mm_atomic.LoadUint64(&m.afterDeleteByTgUsernameCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteByTgUsernameInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockDeleteByTgUsernameInspect() {
	for _, e := range m.DeleteByTgUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.DeleteByTgUsername with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteByTgUsernameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteByTgUsernameCounter) < 1 {
		if m.DeleteByTgUsernameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.DeleteByTgUsername")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.DeleteByTgUsername with params: %#v", *m.DeleteByTgUsernameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteByTgUsername != nil && mm_atomic.LoadUint64(&m.afterDeleteByTgUsernameCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.DeleteByTgUsername")
	}
}

type mUserRepositoryMockDeleteMailbox struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockDeleteMailboxExpectation
	expectations       []*UserRepositoryMockDeleteMailboxExpectation

	callArgs []*UserRepositoryMockDeleteMailboxParams
	mutex    sync.RWMutex
}

// UserRepositoryMockDeleteMailboxExpectation specifies expectation struct of the UserRepository.DeleteMailbox
type UserRepositoryMockDeleteMailboxExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockDeleteMailboxParams
	results *UserRepositoryMockDeleteMailboxResults
	Counter uint64
}

// UserRepositoryMockDeleteMailboxParams contains parameters of the UserRepository.DeleteMailbox
type UserRepositoryMockDeleteMailboxParams struct {
	ctx context.Context
	s1  string
	s2  string
}

// UserRepositoryMockDeleteMailboxResults contains results of the UserRepository.DeleteMailbox
type UserRepositoryMockDeleteMailboxResults struct {
	err error
}

// Expect sets up expected params for UserRepository.DeleteMailbox
func (mmDeleteMailbox *mUserRepositoryMockDeleteMailbox) Expect(ctx context.Context, s1 string, s2 string) *mUserRepositoryMockDeleteMailbox {
	if mmDeleteMailbox.mock.funcDeleteMailbox != nil {
		mmDeleteMailbox.mock.t.Fatalf("UserRepositoryMock.DeleteMailbox mock is already set by Set")
	}

	if mmDeleteMailbox.defaultExpectation == nil {
		mmDeleteMailbox.defaultExpectation = &UserRepositoryMockDeleteMailboxExpectation{}
	}

	mmDeleteMailbox.defaultExpectation.params = &UserRepositoryMockDeleteMailboxParams{ctx, s1, s2}
	for _, e := range mmDeleteMailbox.expectations {
		if minimock.Equal(e.params, mmDeleteMailbox.defaultExpectation.params) {
			mmDeleteMailbox.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteMailbox.defaultExpectation.params)
		}
	}

	return mmDeleteMailbox
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.DeleteMailbox
func (mmDeleteMailbox *mUserRepositoryMockDeleteMailbox) Inspect(f func(ctx context.Context, s1 string, s2 string)) *mUserRepositoryMockDeleteMailbox {
	if mmDeleteMailbox.mock.inspectFuncDeleteMailbox != nil {
		mmDeleteMailbox.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.DeleteMailbox")
	}

	mmDeleteMailbox.mock.inspectFuncDeleteMailbox = f

	return mmDeleteMailbox
}

// Return sets up results that will be returned by UserRepository.DeleteMailbox
func (mmDeleteMailbox *mUserRepositoryMockDeleteMailbox) Return(err error) *UserRepositoryMock {
	if mmDeleteMailbox.mock.funcDeleteMailbox != nil {
		mmDeleteMailbox.mock.t.Fatalf("UserRepositoryMock.DeleteMailbox mock is already set by Set")
	}

	if mmDeleteMailbox.defaultExpectation == nil {
		mmDeleteMailbox.defaultExpectation = &UserRepositoryMockDeleteMailboxExpectation{mock: mmDeleteMailbox.mock}
	}
	mmDeleteMailbox.defaultExpectation.results = &UserRepositoryMockDeleteMailboxResults{err}
	return mmDeleteMailbox.mock
}

//Set uses given function f to mock the UserRepository.DeleteMailbox method
func (mmDeleteMailbox *mUserRepositoryMockDeleteMailbox) Set(f func(ctx context.Context, s1 string, s2 string) (err error)) *UserRepositoryMock {
	if mmDeleteMailbox.defaultExpectation != nil {
		mmDeleteMailbox.mock.t.Fatalf("Default expectation is already set for the UserRepository.DeleteMailbox method")
	}

	if len(mmDeleteMailbox.expectations) > 0 {
		mmDeleteMailbox.mock.t.Fatalf("Some expectations are already set for the UserRepository.DeleteMailbox method")
	}

	mmDeleteMailbox.mock.funcDeleteMailbox = f
	return mmDeleteMailbox.mock
}

// When sets expectation for the UserRepository.DeleteMailbox which will trigger the result defined by the following
// Then helper
func (mmDeleteMailbox *mUserRepositoryMockDeleteMailbox) When(ctx context.Context, s1 string, s2 string) *UserRepositoryMockDeleteMailboxExpectation {
	if mmDeleteMailbox.mock.funcDeleteMailbox != nil {
		mmDeleteMailbox.mock.t.Fatalf("UserRepositoryMock.DeleteMailbox mock is already set by Set")
	}

	expectation := &UserRepositoryMockDeleteMailboxExpectation{
		mock:   mmDeleteMailbox.mock,
		params: &UserRepositoryMockDeleteMailboxParams{ctx, s1, s2},
	}
	mmDeleteMailbox.expectations = append(mmDeleteMailbox.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.DeleteMailbox return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockDeleteMailboxExpectation) Then(err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockDeleteMailboxResults{err}
	return e.mock
}

// DeleteMailbox implements UserRepository
func (mmDeleteMailbox *UserRepositoryMock) DeleteMailbox(ctx context.Context, s1 string, s2 string) (err error) {
	mm_atomic.AddUint64(&mmDeleteMailbox.beforeDeleteMailboxCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteMailbox.afterDeleteMailboxCounter, 1)

	if mmDeleteMailbox.inspectFuncDeleteMailbox != nil {
		mmDeleteMailbox.inspectFuncDeleteMailbox(ctx, s1, s2)
	}

	mm_params := &UserRepositoryMockDeleteMailboxParams{ctx, s1, s2}

	// Record call args
	mmDeleteMailbox.DeleteMailboxMock.mutex.Lock()
	mmDeleteMailbox.DeleteMailboxMock.callArgs = append(mmDeleteMailbox.DeleteMailboxMock.callArgs, mm_params)
	mmDeleteMailbox.DeleteMailboxMock.mutex.Unlock()

	for _, e := range mmDeleteMailbox.DeleteMailboxMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteMailbox.DeleteMailboxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteMailbox.DeleteMailboxMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteMailbox.DeleteMailboxMock.defaultExpectation.params
		mm_got := UserRepositoryMockDeleteMailboxParams{ctx, s1, s2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteMailbox.t.Errorf("UserRepositoryMock.DeleteMailbox got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteMailbox.DeleteMailboxMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteMailbox.t.Fatal("No results are set for the UserRepositoryMock.DeleteMailbox")
		}
		return (*mm_results).err
	}
	if mmDeleteMailbox.funcDeleteMailbox != nil {
		return mmDeleteMailbox.funcDeleteMailbox(ctx, s1, s2)
	}
	mmDeleteMailbox.t.Fatalf("Unexpected call to UserRepositoryMock.DeleteMailbox. %v %v %v", ctx, s1, s2)
	return
}

// DeleteMailboxAfterCounter returns a count of finished UserRepositoryMock.DeleteMailbox invocations
func (mmDeleteMailbox *UserRepositoryMock) DeleteMailboxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMailbox.afterDeleteMailboxCounter)
}

// DeleteMailboxBeforeCounter returns a count of UserRepositoryMock.DeleteMailbox invocations
func (mmDeleteMailbox *UserRepositoryMock) DeleteMailboxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMailbox.beforeDeleteMailboxCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.DeleteMailbox.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteMailbox *mUserRepositoryMockDeleteMailbox) Calls() []*UserRepositoryMockDeleteMailboxParams {
	mmDeleteMailbox.mutex.RLock()

	argCopy := make([]*UserRepositoryMockDeleteMailboxParams, len(mmDeleteMailbox.callArgs))
	copy(argCopy, mmDeleteMailbox.callArgs)

	mmDeleteMailbox.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteMailboxDone returns true if the count of the DeleteMailbox invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockDeleteMailboxDone() bool {
	for _, e := range m.DeleteMailboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMailboxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMailbox != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteMailboxInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockDeleteMailboxInspect() {
	for _, e := range m.DeleteMailboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.DeleteMailbox with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMailboxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxCounter) < 1 {
		if m.DeleteMailboxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.DeleteMailbox")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.DeleteMailbox with params: %#v", *m.DeleteMailboxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMailbox != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.DeleteMailbox")
	}
}

type mUserRepositoryMockGetByTgUsername struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetByTgUsernameExpectation
	expectations       []*UserRepositoryMockGetByTgUsernameExpectation

	callArgs []*UserRepositoryMockGetByTgUsernameParams
	mutex    sync.RWMutex
}

// UserRepositoryMockGetByTgUsernameExpectation specifies expectation struct of the UserRepository.GetByTgUsername
type UserRepositoryMockGetByTgUsernameExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockGetByTgUsernameParams
	results *UserRepositoryMockGetByTgUsernameResults
	Counter uint64
}

// UserRepositoryMockGetByTgUsernameParams contains parameters of the UserRepository.GetByTgUsername
type UserRepositoryMockGetByTgUsernameParams struct {
	ctx context.Context
	s1  string
}

// UserRepositoryMockGetByTgUsernameResults contains results of the UserRepository.GetByTgUsername
type UserRepositoryMockGetByTgUsernameResults struct {
	u1  models.User
	err error
}

// Expect sets up expected params for UserRepository.GetByTgUsername
func (mmGetByTgUsername *mUserRepositoryMockGetByTgUsername) Expect(ctx context.Context, s1 string) *mUserRepositoryMockGetByTgUsername {
	if mmGetByTgUsername.mock.funcGetByTgUsername != nil {
		mmGetByTgUsername.mock.t.Fatalf("UserRepositoryMock.GetByTgUsername mock is already set by Set")
	}

	if mmGetByTgUsername.defaultExpectation == nil {
		mmGetByTgUsername.defaultExpectation = &UserRepositoryMockGetByTgUsernameExpectation{}
	}

	mmGetByTgUsername.defaultExpectation.params = &UserRepositoryMockGetByTgUsernameParams{ctx, s1}
	for _, e := range mmGetByTgUsername.expectations {
		if minimock.Equal(e.params, mmGetByTgUsername.defaultExpectation.params) {
			mmGetByTgUsername.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByTgUsername.defaultExpectation.params)
		}
	}

	return mmGetByTgUsername
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetByTgUsername
func (mmGetByTgUsername *mUserRepositoryMockGetByTgUsername) Inspect(f func(ctx context.Context, s1 string)) *mUserRepositoryMockGetByTgUsername {
	if mmGetByTgUsername.mock.inspectFuncGetByTgUsername != nil {
		mmGetByTgUsername.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetByTgUsername")
	}

	mmGetByTgUsername.mock.inspectFuncGetByTgUsername = f

	return mmGetByTgUsername
}

// Return sets up results that will be returned by UserRepository.GetByTgUsername
func (mmGetByTgUsername *mUserRepositoryMockGetByTgUsername) Return(u1 models.User, err error) *UserRepositoryMock {
	if mmGetByTgUsername.mock.funcGetByTgUsername != nil {
		mmGetByTgUsername.mock.t.Fatalf("UserRepositoryMock.GetByTgUsername mock is already set by Set")
	}

	if mmGetByTgUsername.defaultExpectation == nil {
		mmGetByTgUsername.defaultExpectation = &UserRepositoryMockGetByTgUsernameExpectation{mock: mmGetByTgUsername.mock}
	}
	mmGetByTgUsername.defaultExpectation.results = &UserRepositoryMockGetByTgUsernameResults{u1, err}
	return mmGetByTgUsername.mock
}

//Set uses given function f to mock the UserRepository.GetByTgUsername method
func (mmGetByTgUsername *mUserRepositoryMockGetByTgUsername) Set(f func(ctx context.Context, s1 string) (u1 models.User, err error)) *UserRepositoryMock {
	if mmGetByTgUsername.defaultExpectation != nil {
		mmGetByTgUsername.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetByTgUsername method")
	}

	if len(mmGetByTgUsername.expectations) > 0 {
		mmGetByTgUsername.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetByTgUsername method")
	}

	mmGetByTgUsername.mock.funcGetByTgUsername = f
	return mmGetByTgUsername.mock
}

// When sets expectation for the UserRepository.GetByTgUsername which will trigger the result defined by the following
// Then helper
func (mmGetByTgUsername *mUserRepositoryMockGetByTgUsername) When(ctx context.Context, s1 string) *UserRepositoryMockGetByTgUsernameExpectation {
	if mmGetByTgUsername.mock.funcGetByTgUsername != nil {
		mmGetByTgUsername.mock.t.Fatalf("UserRepositoryMock.GetByTgUsername mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetByTgUsernameExpectation{
		mock:   mmGetByTgUsername.mock,
		params: &UserRepositoryMockGetByTgUsernameParams{ctx, s1},
	}
	mmGetByTgUsername.expectations = append(mmGetByTgUsername.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetByTgUsername return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetByTgUsernameExpectation) Then(u1 models.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetByTgUsernameResults{u1, err}
	return e.mock
}

// GetByTgUsername implements UserRepository
func (mmGetByTgUsername *UserRepositoryMock) GetByTgUsername(ctx context.Context, s1 string) (u1 models.User, err error) {
	mm_atomic.AddUint64(&mmGetByTgUsername.beforeGetByTgUsernameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByTgUsername.afterGetByTgUsernameCounter, 1)

	if mmGetByTgUsername.inspectFuncGetByTgUsername != nil {
		mmGetByTgUsername.inspectFuncGetByTgUsername(ctx, s1)
	}

	mm_params := &UserRepositoryMockGetByTgUsernameParams{ctx, s1}

	// Record call args
	mmGetByTgUsername.GetByTgUsernameMock.mutex.Lock()
	mmGetByTgUsername.GetByTgUsernameMock.callArgs = append(mmGetByTgUsername.GetByTgUsernameMock.callArgs, mm_params)
	mmGetByTgUsername.GetByTgUsernameMock.mutex.Unlock()

	for _, e := range mmGetByTgUsername.GetByTgUsernameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetByTgUsername.GetByTgUsernameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByTgUsername.GetByTgUsernameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByTgUsername.GetByTgUsernameMock.defaultExpectation.params
		mm_got := UserRepositoryMockGetByTgUsernameParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByTgUsername.t.Errorf("UserRepositoryMock.GetByTgUsername got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByTgUsername.GetByTgUsernameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByTgUsername.t.Fatal("No results are set for the UserRepositoryMock.GetByTgUsername")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetByTgUsername.funcGetByTgUsername != nil {
		return mmGetByTgUsername.funcGetByTgUsername(ctx, s1)
	}
	mmGetByTgUsername.t.Fatalf("Unexpected call to UserRepositoryMock.GetByTgUsername. %v %v", ctx, s1)
	return
}

// GetByTgUsernameAfterCounter returns a count of finished UserRepositoryMock.GetByTgUsername invocations
func (mmGetByTgUsername *UserRepositoryMock) GetByTgUsernameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByTgUsername.afterGetByTgUsernameCounter)
}

// GetByTgUsernameBeforeCounter returns a count of UserRepositoryMock.GetByTgUsername invocations
func (mmGetByTgUsername *UserRepositoryMock) GetByTgUsernameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByTgUsername.beforeGetByTgUsernameCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetByTgUsername.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByTgUsername *mUserRepositoryMockGetByTgUsername) Calls() []*UserRepositoryMockGetByTgUsernameParams {
	mmGetByTgUsername.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetByTgUsernameParams, len(mmGetByTgUsername.callArgs))
	copy(argCopy, mmGetByTgUsername.callArgs)

	mmGetByTgUsername.mutex.RUnlock()

	return argCopy
}

// MinimockGetByTgUsernameDone returns true if the count of the GetByTgUsername invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetByTgUsernameDone() bool {
	for _, e := range m.GetByTgUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByTgUsernameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByTgUsernameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByTgUsername != nil && mm_atomic.LoadUint64(&m.afterGetByTgUsernameCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetByTgUsernameInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetByTgUsernameInspect() {
	for _, e := range m.GetByTgUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetByTgUsername with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetByTgUsernameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetByTgUsernameCounter) < 1 {
		if m.GetByTgUsernameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.GetByTgUsername")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetByTgUsername with params: %#v", *m.GetByTgUsernameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByTgUsername != nil && mm_atomic.LoadUint64(&m.afterGetByTgUsernameCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.GetByTgUsername")
	}
}

type mUserRepositoryMockGetList struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetListExpectation
	expectations       []*UserRepositoryMockGetListExpectation

	callArgs []*UserRepositoryMockGetListParams
	mutex    sync.RWMutex
}

// UserRepositoryMockGetListExpectation specifies expectation struct of the UserRepository.GetList
type UserRepositoryMockGetListExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockGetListParams
	results *UserRepositoryMockGetListResults
	Counter uint64
}

// UserRepositoryMockGetListParams contains parameters of the UserRepository.GetList
type UserRepositoryMockGetListParams struct {
	ctx context.Context
}

// UserRepositoryMockGetListResults contains results of the UserRepository.GetList
type UserRepositoryMockGetListResults struct {
	ua1 []models.User
	err error
}

// Expect sets up expected params for UserRepository.GetList
func (mmGetList *mUserRepositoryMockGetList) Expect(ctx context.Context) *mUserRepositoryMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("UserRepositoryMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &UserRepositoryMockGetListExpectation{}
	}

	mmGetList.defaultExpectation.params = &UserRepositoryMockGetListParams{ctx}
	for _, e := range mmGetList.expectations {
		if minimock.Equal(e.params, mmGetList.defaultExpectation.params) {
			mmGetList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetList.defaultExpectation.params)
		}
	}

	return mmGetList
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetList
func (mmGetList *mUserRepositoryMockGetList) Inspect(f func(ctx context.Context)) *mUserRepositoryMockGetList {
	if mmGetList.mock.inspectFuncGetList != nil {
		mmGetList.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetList")
	}

	mmGetList.mock.inspectFuncGetList = f

	return mmGetList
}

// Return sets up results that will be returned by UserRepository.GetList
func (mmGetList *mUserRepositoryMockGetList) Return(ua1 []models.User, err error) *UserRepositoryMock {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("UserRepositoryMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &UserRepositoryMockGetListExpectation{mock: mmGetList.mock}
	}
	mmGetList.defaultExpectation.results = &UserRepositoryMockGetListResults{ua1, err}
	return mmGetList.mock
}

//Set uses given function f to mock the UserRepository.GetList method
func (mmGetList *mUserRepositoryMockGetList) Set(f func(ctx context.Context) (ua1 []models.User, err error)) *UserRepositoryMock {
	if mmGetList.defaultExpectation != nil {
		mmGetList.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetList method")
	}

	if len(mmGetList.expectations) > 0 {
		mmGetList.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetList method")
	}

	mmGetList.mock.funcGetList = f
	return mmGetList.mock
}

// When sets expectation for the UserRepository.GetList which will trigger the result defined by the following
// Then helper
func (mmGetList *mUserRepositoryMockGetList) When(ctx context.Context) *UserRepositoryMockGetListExpectation {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("UserRepositoryMock.GetList mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetListExpectation{
		mock:   mmGetList.mock,
		params: &UserRepositoryMockGetListParams{ctx},
	}
	mmGetList.expectations = append(mmGetList.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetList return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetListExpectation) Then(ua1 []models.User, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetListResults{ua1, err}
	return e.mock
}

// GetList implements UserRepository
func (mmGetList *UserRepositoryMock) GetList(ctx context.Context) (ua1 []models.User, err error) {
	mm_atomic.AddUint64(&mmGetList.beforeGetListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetList.afterGetListCounter, 1)

	if mmGetList.inspectFuncGetList != nil {
		mmGetList.inspectFuncGetList(ctx)
	}

	mm_params := &UserRepositoryMockGetListParams{ctx}

	// Record call args
	mmGetList.GetListMock.mutex.Lock()
	mmGetList.GetListMock.callArgs = append(mmGetList.GetListMock.callArgs, mm_params)
	mmGetList.GetListMock.mutex.Unlock()

	for _, e := range mmGetList.GetListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetList.GetListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetList.GetListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetList.GetListMock.defaultExpectation.params
		mm_got := UserRepositoryMockGetListParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetList.t.Errorf("UserRepositoryMock.GetList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetList.GetListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetList.t.Fatal("No results are set for the UserRepositoryMock.GetList")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetList.funcGetList != nil {
		return mmGetList.funcGetList(ctx)
	}
	mmGetList.t.Fatalf("Unexpected call to UserRepositoryMock.GetList. %v", ctx)
	return
}

// GetListAfterCounter returns a count of finished UserRepositoryMock.GetList invocations
func (mmGetList *UserRepositoryMock) GetListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.afterGetListCounter)
}

// GetListBeforeCounter returns a count of UserRepositoryMock.GetList invocations
func (mmGetList *UserRepositoryMock) GetListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.beforeGetListCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetList *mUserRepositoryMockGetList) Calls() []*UserRepositoryMockGetListParams {
	mmGetList.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetListParams, len(mmGetList.callArgs))
	copy(argCopy, mmGetList.callArgs)

	mmGetList.mutex.RUnlock()

	return argCopy
}

// MinimockGetListDone returns true if the count of the GetList invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetListDone() bool {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetListInspect() {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		if m.GetListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.GetList")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetList with params: %#v", *m.GetListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.GetList")
	}
}

type mUserRepositoryMockGetMailboxes struct {
	mock               *UserRepositoryMock
	defaultExpectation *UserRepositoryMockGetMailboxesExpectation
	expectations       []*UserRepositoryMockGetMailboxesExpectation

	callArgs []*UserRepositoryMockGetMailboxesParams
	mutex    sync.RWMutex
}

// UserRepositoryMockGetMailboxesExpectation specifies expectation struct of the UserRepository.GetMailboxes
type UserRepositoryMockGetMailboxesExpectation struct {
	mock    *UserRepositoryMock
	params  *UserRepositoryMockGetMailboxesParams
	results *UserRepositoryMockGetMailboxesResults
	Counter uint64
}

// UserRepositoryMockGetMailboxesParams contains parameters of the UserRepository.GetMailboxes
type UserRepositoryMockGetMailboxesParams struct {
	ctx context.Context
	s1  string
}

// UserRepositoryMockGetMailboxesResults contains results of the UserRepository.GetMailboxes
type UserRepositoryMockGetMailboxesResults struct {
	ma1 []models.Mailbox
	err error
}

// Expect sets up expected params for UserRepository.GetMailboxes
func (mmGetMailboxes *mUserRepositoryMockGetMailboxes) Expect(ctx context.Context, s1 string) *mUserRepositoryMockGetMailboxes {
	if mmGetMailboxes.mock.funcGetMailboxes != nil {
		mmGetMailboxes.mock.t.Fatalf("UserRepositoryMock.GetMailboxes mock is already set by Set")
	}

	if mmGetMailboxes.defaultExpectation == nil {
		mmGetMailboxes.defaultExpectation = &UserRepositoryMockGetMailboxesExpectation{}
	}

	mmGetMailboxes.defaultExpectation.params = &UserRepositoryMockGetMailboxesParams{ctx, s1}
	for _, e := range mmGetMailboxes.expectations {
		if minimock.Equal(e.params, mmGetMailboxes.defaultExpectation.params) {
			mmGetMailboxes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMailboxes.defaultExpectation.params)
		}
	}

	return mmGetMailboxes
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.GetMailboxes
func (mmGetMailboxes *mUserRepositoryMockGetMailboxes) Inspect(f func(ctx context.Context, s1 string)) *mUserRepositoryMockGetMailboxes {
	if mmGetMailboxes.mock.inspectFuncGetMailboxes != nil {
		mmGetMailboxes.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.GetMailboxes")
	}

	mmGetMailboxes.mock.inspectFuncGetMailboxes = f

	return mmGetMailboxes
}

// Return sets up results that will be returned by UserRepository.GetMailboxes
func (mmGetMailboxes *mUserRepositoryMockGetMailboxes) Return(ma1 []models.Mailbox, err error) *UserRepositoryMock {
	if mmGetMailboxes.mock.funcGetMailboxes != nil {
		mmGetMailboxes.mock.t.Fatalf("UserRepositoryMock.GetMailboxes mock is already set by Set")
	}

	if mmGetMailboxes.defaultExpectation == nil {
		mmGetMailboxes.defaultExpectation = &UserRepositoryMockGetMailboxesExpectation{mock: mmGetMailboxes.mock}
	}
	mmGetMailboxes.defaultExpectation.results = &UserRepositoryMockGetMailboxesResults{ma1, err}
	return mmGetMailboxes.mock
}

//Set uses given function f to mock the UserRepository.GetMailboxes method
func (mmGetMailboxes *mUserRepositoryMockGetMailboxes) Set(f func(ctx context.Context, s1 string) (ma1 []models.Mailbox, err error)) *UserRepositoryMock {
	if mmGetMailboxes.defaultExpectation != nil {
		mmGetMailboxes.mock.t.Fatalf("Default expectation is already set for the UserRepository.GetMailboxes method")
	}

	if len(mmGetMailboxes.expectations) > 0 {
		mmGetMailboxes.mock.t.Fatalf("Some expectations are already set for the UserRepository.GetMailboxes method")
	}

	mmGetMailboxes.mock.funcGetMailboxes = f
	return mmGetMailboxes.mock
}

// When sets expectation for the UserRepository.GetMailboxes which will trigger the result defined by the following
// Then helper
func (mmGetMailboxes *mUserRepositoryMockGetMailboxes) When(ctx context.Context, s1 string) *UserRepositoryMockGetMailboxesExpectation {
	if mmGetMailboxes.mock.funcGetMailboxes != nil {
		mmGetMailboxes.mock.t.Fatalf("UserRepositoryMock.GetMailboxes mock is already set by Set")
	}

	expectation := &UserRepositoryMockGetMailboxesExpectation{
		mock:   mmGetMailboxes.mock,
		params: &UserRepositoryMockGetMailboxesParams{ctx, s1},
	}
	mmGetMailboxes.expectations = append(mmGetMailboxes.expectations, expectation)
	return expectation
}

// Then sets up UserRepository.GetMailboxes return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetMailboxesExpectation) Then(ma1 []models.Mailbox, err error) *UserRepositoryMock {
	e.results = &UserRepositoryMockGetMailboxesResults{ma1, err}
	return e.mock
}

// GetMailboxes implements UserRepository
func (mmGetMailboxes *UserRepositoryMock) GetMailboxes(ctx context.Context, s1 string) (ma1 []models.Mailbox, err error) {
	mm_atomic.AddUint64(&mmGetMailboxes.beforeGetMailboxesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMailboxes.afterGetMailboxesCounter, 1)

	if mmGetMailboxes.inspectFuncGetMailboxes != nil {
		mmGetMailboxes.inspectFuncGetMailboxes(ctx, s1)
	}

	mm_params := &UserRepositoryMockGetMailboxesParams{ctx, s1}

	// Record call args
	mmGetMailboxes.GetMailboxesMock.mutex.Lock()
	mmGetMailboxes.GetMailboxesMock.callArgs = append(mmGetMailboxes.GetMailboxesMock.callArgs, mm_params)
	mmGetMailboxes.GetMailboxesMock.mutex.Unlock()

	for _, e := range mmGetMailboxes.GetMailboxesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmGetMailboxes.GetMailboxesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMailboxes.GetMailboxesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetMailboxes.GetMailboxesMock.defaultExpectation.params
		mm_got := UserRepositoryMockGetMailboxesParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMailboxes.t.Errorf("UserRepositoryMock.GetMailboxes got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMailboxes.GetMailboxesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMailboxes.t.Fatal("No results are set for the UserRepositoryMock.GetMailboxes")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmGetMailboxes.funcGetMailboxes != nil {
		return mmGetMailboxes.funcGetMailboxes(ctx, s1)
	}
	mmGetMailboxes.t.Fatalf("Unexpected call to UserRepositoryMock.GetMailboxes. %v %v", ctx, s1)
	return
}

// GetMailboxesAfterCounter returns a count of finished UserRepositoryMock.GetMailboxes invocations
func (mmGetMailboxes *UserRepositoryMock) GetMailboxesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMailboxes.afterGetMailboxesCounter)
}

// GetMailboxesBeforeCounter returns a count of UserRepositoryMock.GetMailboxes invocations
func (mmGetMailboxes *UserRepositoryMock) GetMailboxesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMailboxes.beforeGetMailboxesCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryMock.GetMailboxes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMailboxes *mUserRepositoryMockGetMailboxes) Calls() []*UserRepositoryMockGetMailboxesParams {
	mmGetMailboxes.mutex.RLock()

	argCopy := make([]*UserRepositoryMockGetMailboxesParams, len(mmGetMailboxes.callArgs))
	copy(argCopy, mmGetMailboxes.callArgs)

	mmGetMailboxes.mutex.RUnlock()

	return argCopy
}

// MinimockGetMailboxesDone returns true if the count of the GetMailboxes invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetMailboxesDone() bool {
	for _, e := range m.GetMailboxesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMailboxesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMailboxesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMailboxes != nil && mm_atomic.LoadUint64(&m.afterGetMailboxesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMailboxesInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetMailboxesInspect() {
	for _, e := range m.GetMailboxesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryMock.GetMailboxes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMailboxesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMailboxesCounter) < 1 {
		if m.GetMailboxesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepositoryMock.GetMailboxes")
		} else {
			m.t.Errorf("Expected call to UserRepositoryMock.GetMailboxes with params: %#v", *m.GetMailboxesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMailboxes != nil && mm_atomic.LoadUint64(&m.afterGetMailboxesCounter) < 1 {
		m.t.Error("Expected call to UserRepositoryMock.GetMailboxes")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockCreateMailboxInspect()

		m.MinimockDeleteByTgUsernameInspect()

		m.MinimockDeleteMailboxInspect()

		m.MinimockGetByTgUsernameInspect()

		m.MinimockGetListInspect()

		m.MinimockGetMailboxesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockCreateMailboxDone() &&
		m.MinimockDeleteByTgUsernameDone() &&
		m.MinimockDeleteMailboxDone() &&
		m.MinimockGetByTgUsernameDone() &&
		m.MinimockGetListDone() &&
		m.MinimockGetMailboxesDone()
}
